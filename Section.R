# License Terms and Conditions############################################################################ Limited rights are hereby granted under a Creative Commons CC BY-NC license to # anyone acquiring this software. This license lets anyone remix, tweak, and build upon the # work non-commercially, and new works must also acknowledge the copyright owner and # be non- commercial. See license text at: https://creativecommons.org/licenses/by-nc/4.0/ # Additional: # (1) anyone editing or re-distributing this software or any portion of it must include # the above license link, attribute copyrights in the code to Eamon O Doherty, and# clearly indicate any modifications made to the code. Licenses to third-party libraries # are cited below; # (2) commercial use is not permitted either of this code or any derived works;# (3) the code for purposes of this license is deemed to include and cover: Saxify.R file # and related files Work.R, Section.R and Plotter.R############################################################################ Phase 0: Purpose:############################################################################ This file defines a R6 class named 'Section' to represent a Section of a      # recording being processed in a run of Saxify. A Work object will be created by # the calling program to represent all of the performances. For each performance this# class will then generate one Section object for each structural segment mapped in the     # performed work. This essentially replicated the process performed in Work on the complete# performance - but at a sectional level####################################################################################################################################################### defines the public/private data of the Class and the methods used by it###########################################################################Section  <- R6Class("Section",    public = list(    sectionNumber = "numeric",     sectionName = "character",     startBar = "numeric",     endBar = "numeric",     startBeat = "numeric",     endBeat = "numeric",     subSectionName = "character",     bpm = "numeric",     timeSignature = "character",     totalBeats = "numeric",    startRow = "numeric",    endRow = "numeric",    SAXarray = list(),    SAXarrayx = list(),    SAXarrayy = list(),    dm = matrix(),    dmx = matrix(),    dmy = matrix(),    years = c(),    xls = array(),    originalX = c(),    originalY = c(),    x = c(),    y = c(),    z = c(),    seriesLength = "numeric",    paa = c(),    paax = c(),    paay = c(),    alpha = "numeric",    SAXstring = "character",    SAXstringx = "character",    SAXstringy = "character",    varNames = c(),    weights = c(),    frames = "numeric",    performances = c(),    beatsDroppedStart = "numeric",    beatsDroppedEnd = "numeric",    locationDM = "character",    ############################################################################ initialize is the class constructor, called immediately and automatically when an object# of this class is created. The calling program Saxify.R passes the parameters that are # shown in parentheses###########################################################################    initialize = function (sectionNumber, sectionName, startBar, endBar,                            startBeat, endBeat, subSectionName, bpm, timeSignature, totalBeats, startRow, endRow) {      self$sectionNumber <- sectionNumber      self$sectionName <- sectionName      self$startBar <- startBar      self$endBar <- endBar      self$startBeat <- startBeat      self$endBeat <- endBeat      self$subSectionName <- subSectionName      self$bpm <- bpm      self$timeSignature <- timeSignature      self$totalBeats <- totalBeats      self$startRow <- startRow      self$endRow <- endRow               },        ############################################################################ FR10: consider using lapply to replace the 'for loop' in here###########################################################################    getData = function(performances, alpha, beatsDroppedStart, beatsDroppedEnd) {            self$alpha <- alpha      self$performances <- performances      self$beatsDroppedStart <- beatsDroppedStart      self$beatsDroppedEnd <- beatsDroppedEnd      self$SAXarray <- list(length(self$performances)+1)      self$SAXarrayx <- list(length(self$performances)+1)      self$SAXarrayy <- list(length(self$performances)+1)            ############################################################################ create a DM; add 1 to cover the PNT###########################################################################      self$dm = matrix(nrow=length(self$performances)+1, ncol=length(self$performances)+1)            ############################################################################ create individual DMs for each of the individual variables. # These will output to new tabs on the worksheet###########################################################################      self$dmx = matrix(nrow=length(self$performances)+1, ncol=length(self$performances)+1)      self$dmy = matrix(nrow=length(self$performances)+1, ncol=length(self$performances)+1)            self$xls <- read_xlsx(locationPNT, col_types=NULL, sheet="PT Calcs", col_names=TRUE, skip=0)      ############################################################################ Only store the bars/beats indicated on the map for this section###########################################################################            self$originalX = as.numeric( self$xls[[PNTcol1]] )       self$originalY = as.numeric( self$xls[[PNTcol2]] )       ###########################################################################      ############################################################################Adjust for actual start & end (offset is beatsDroppedStart from actual)# self$x = self$originalX[self$beatsDroppedStart+self$startBeat:self$endBeat]# self$y = self$originalY[self$beatsDroppedStart+self$startBeat:self$endBeat]###########################################################################      self$x = self$originalX[self$startRow:self$endRow]      self$y = self$originalY[self$startRow:self$endRow]      ############################################################################ store length of series Ð actuals###########################################################################      self$seriesLength <- self$totalBeats      ############################################################################ for section processing, redefine frames to actual size# could check here that seriesLength is not greater than self$frames###########################################################################             self$frames = self$seriesLength            ############################################################################ normalize each performance variable###########################################################################      self$x <- (self$x - mean(self$x)) /sd(self$x)      self$y <- (self$y - mean(self$y)) /sd(self$y)            ############################################################################ Generate PAA reductions (complete, then individual variables). For section # DMs use the actual length of the section rather than the global Frames variable###########################################################################      self$paax <- PAA(self$x, self$frames)      self$paay <- PAA(self$y, self$frames)            ############################################################################ convert to symbol string###########################################################################      self$SAXstringx <- convert.to.SAX.symbol(self$paax, self$alpha)      self$SAXstringy <- convert.to.SAX.symbol(self$paay, self$alpha)      ############################################################################ store the symbol string representation in an object###########################################################################      self$SAXarrayx[[1]] <- self$SAXstringx      self$SAXarrayy[[1]] <- self$SAXstringy            idx<- 2      printed<-0            for (rec in performances) {                        printed <- printed +1                self$xls <- read_xlsx(locationPNT, col_types=NULL, sheet=rec, col_names=TRUE, skip=0)                self$originalX <- as.numeric( self$xls[[RECcol1]] )         self$originalY <- as.numeric( self$xls[[RECcol2]] )                         ############################################################################ adjust for actual start & end# (offset is beatsDroppedStart from actual)###########################################################################        self$x = self$originalX[self$startRow:self$endRow]        self$y = self$originalY[self$startRow:self$endRow]                ############################################################################ normalize###########################################################################        self$x <- (self$x - mean(self$x)) /sd(self$x)        self$y <- (self$y - mean(self$y)) /sd(self$y)         ############################################################################ store length of series Ð actual###########################################################################        self$seriesLength <- self$totalBeats                ############################################################################ for section processing, redefine frames to actual size###########################################################################        self$frames = self$seriesLength        ############################################################################ generate PAA reductions###########################################################################                self$paax <- PAA(self$x, self$frames)        self$paay <- PAA(self$y, self$frames)                ############################################################################ convert to symbolic representation###########################################################################        self$SAXstringx <- convert.to.SAX.symbol(self$paax, alpha)        self$SAXstringy <- convert.to.SAX.symbol(self$paay, alpha)                ############################################################################ store the SAX representations in vector###########################################################################        self$SAXarrayx[[idx]] <- self$SAXstringx        self$SAXarrayy[[idx]] <- self$SAXstringy                idx <- idx+1        if (printed == 15) {          cat ("\n")          printed <- 0        }      }         },        ############################################################################ function to calculate pairwise SAX dissimilarities###########################################################################    pairwise = function (strA, strB) {      v <- mindist.sax(strA, strB, self$alpha, self$seriesLength)      return (as.numeric(format(round(v,2), nsmall=2)))    },         doDistanceMatrix = function(type) {      # FR11: add a distinguishing section identifier to locationDM      self$locationDM <- paste(locDM, "/dmSection", sep="")      self$locationDM <- paste(self$locationDM, self$sectionNumber, sep="")      self$locationDM <- paste(self$locationDM, ".xlsx", sep="")      self$locationDM <- path.expand(self$locationDM)            if (type==1) {        rownames(self$dm)<- c("PN", self$performances)        colnames(self$dm)<- c("PN", self$performances)                for(i in 1:dim(self$dm)[1]) { # for each row          for(j in 1:dim(self$dm)[2]) { # for each column            self$dm[i,j] <-   self$dmx[i,j]*weights[1] + self$dmy[i,j]*weights[2]         #weighted average              }        }        # output DM to disk        write.xlsx (self$dm, self$locationDM, sheetName="dm-Combined", col.names=TRUE, row.names=TRUE, append=TRUE)      }      if (type == 2) {        rownames(self$dmx)<- c("PN", self$performances)        colnames(self$dmx)<- c("PN", self$performances)                for(i in 1:dim(self$dmx)[1]) { # for each row          for(j in 1:dim(self$dmx)[2]) { # for each column            self$dmx[i,j] <- self$pairwise(self$SAXarrayx[[i]], self$SAXarrayx[[j]])               }        }        # output DM to disk        write.xlsx (self$dmx, self$locationDM, sheetName=PNTcolHead1, col.names=TRUE, row.names=TRUE, append=TRUE)      }      if (type == 3) {        rownames(self$dmy)<- c("PN", self$performances)        colnames(self$dmy)<- c("PN", self$performances)                for(i in 1:dim(self$dmy)[1]) { # for each row          for(j in 1:dim(self$dmy)[2]) { # for each column            self$dmy[i,j] <- self$pairwise(self$SAXarrayy[[i]], self$SAXarrayy[[j]])               }        }        # output DM to disk        write.xlsx (self$dmy, self$locationDM, sheetName=PNTcolHead2, col.names=TRUE, row.names=TRUE, append=FALSE)              }        }      )   )# Section.R version 2.0# Release Date			: June 2018# Author			: Eamon O Doherty# Copyrights asserted by 	: Eamon O Doherty (eamon.odoherty@gmail.com)# Warranties and guarantees	: None provided; use at your own risk# # This file: Section.R.docx