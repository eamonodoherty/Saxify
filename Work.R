# License Terms and Conditions############################################################################ Limited rights are hereby granted under a Creative Commons CC BY-NC license to # anyone acquiring this software. This license lets anyone remix, tweak, and build upon the # work non-commercially, and new works must also acknowledge the copyright owner and # be non-commercial. See license text at: https://creativecommons.org/licenses/by-nc/4.0/ # Additional: # (1) anyone editing or re-distributing this software or any portion of it must include # the above license link, attribute copyrights in the code to Eamon O Doherty, and# clearly indicate any modifications made to the code. Licenses to third-party libraries # are cited below; # (2) commercial use is not permitted either of this code or any derived works;# (3) the code for purposes of this license is deemed to include and cover: Saxify.R file # and related files Work.R, Section.R and Plotter.R############################################################################ Phase 0: Purpose:############################################################################ This file defines a R6 class named 'Work' to represent the complete corpus of      # recordings of a musical work being processed in a run of Saxify. A Work object will be # created by the calling program to represent all of the performances. For each performance # this class will then generate one Section object for each structural segment mapped in the     # work. ####################################################################################################################################################### Individual DMs (dmX, dmY, dmZ etc) need to be declared, and initialized for        # each performance variable. Size of each DM will be the length of the performances # vector.# FR08:This may be improved in a revised version of this code - use an object array of DM ####################################################################################################################################################### defines the public/private data of the Class and the methods used by it###########################################################################Work  <- R6Class("Work",    public = list(     name = "character",     sections = list(),     SAXarray = list(),     SAXarrayx = list(),     SAXarrayy = list(),     dm = matrix(),     dmx = matrix(),     dmy = matrix(),     performances = c(),     xls = array(),     x = c(),     y = c(),     z = c(),     seriesLength = "numeric",     paa = c(),     paax = c(),     paay = c(),     SAXstring = "character",     SAXstringx = "character",     SAXstringy = "character",     alpha = "numeric",     frames = "numeric",     varNames = c(),     weights = c(),     beatsDroppedStart ="numeric",     beatsDroppedEnd = "numeric",     locationDM = "character",     myMap = matrix(),     ############################################################################ Initialize is the class constructor, called immediately and automatically when an object# of this class is created. The calling program Saxify.R passes the parameters that are # shown in parentheses###########################################################################     initialize = function(performances, varNames, alpha, frames, weights, beatsDroppedStart, beatsDroppedEnd, locationDM) {       self$name <- "Schoenberg Phantasy Op. 47"       self$performances <- c(performances)       self$SAXarray <- list(length(performances)+1)       self$SAXarrayx <- list(length(performances)+1)       self$SAXarrayy <- list(length(performances)+1)       self$varNames <- varNames       self$alpha <- alpha       self$frames <- frames       self$weights <- weights       self$beatsDroppedStart <- beatsDroppedStart       self$beatsDroppedEnd <- beatsDroppedEnd       self$locationDM <- locationDM      ############################################################################ map is generated from a textfile named map.csv to represent the section # segmentation of the work. Each item in the map is used to create a Section # object stored as a new Section object in the myMap array###########################################################################       myMap = read.csv(file=locationMAP, header = TRUE, sep = ",")       myMap <- as.matrix(myMap)       for(i in 1:dim(myMap)[1]) { # for each row           self$addSections(Section$new(as.numeric(myMap[i,1]),myMap[i,2],as.numeric(myMap[i,3]),                                        as.numeric(myMap[i,4]),as.numeric(myMap[i,5]),as.numeric(myMap[i,6]),myMap[i,7],as.numeric(myMap[i,8]),myMap[i,9],as.numeric(myMap[i,10]),                                          as.numeric(myMap[i, 11]), as.numeric(myMap[i,12])))       }       ############################################################################ Initialize the DM for the complete work then create a DM; add 1 extra column# to cover the PNT###########################################################################       self$dm = matrix(nrow=length(self$performances)+1, ncol=length(self$performances)+1)              ############################################################################ create individual DMs for each of the individual variables. These will output to new tabs on # the worksheet###########################################################################       self$dmx = matrix(nrow=length(self$performances)+1, ncol=length(self$performances)+1)       self$dmy = matrix(nrow=length(self$performances)+1, ncol=length(self$performances)+1)     },          addSections = function(s) {       self$sections <- c(self$sections, s)     },          ############################################################################ This function calculates pairwise SAX distances using the MINDIST calculation # for a pair of strings but may use any string comparison (eg Levenshtein Distance) # so long as it returns a dissimilarity or distance as a numeric. Dissimilarities are # rounded to 2 decimal points###########################################################################          pairwise = function (strA, strB) {       v <- mindist.sax(strA, strB, self$alpha, self$seriesLength)              return (as.numeric(format(round(v,2), nsmall=2)))     },     ############################################################################ This function reads the input data Ð firstly the PN and then each performance. It# normalizes each series by subtracting its arithmetic mean and dividing by its# standard deviation. Optionally it calculates a weighted combination, performs# Piecewise Aggregate Approximation - symbolizes each PAA string and stores.# The doDistanceMatrix function will be eventually called by the calling program# Saxify.R to generate DMs that include all performances across the variable types.###########################################################################          getData = function() {               self$xls <- read_xlsx(locationPNT, col_types=NULL, sheet="PT Calcs", col_names=TRUE, skip=1)              self$x = as.numeric( self$xls[[PNTcol1]] )        self$y = as.numeric( self$xls[[PNTcol2]] ) ###########################################################################       # store length of series###########################################################################       self$seriesLength <- length(self$x) ###########################################################################      #normalize each performance variable###########################################################################       self$x <- (self$x - mean(self$x)) /sd(self$x)       self$y <- (self$y - mean(self$y)) /sd(self$y) ###########################################################################      # generate weighted series:         <Feature not used at present ># self$z <- (self$x*self$weights[1]) + (self$y*self$weights[2])       # generate PAA reduction (complete performance, then for individual variables)###########################################################################       self$paax <- PAA(self$x, self$frames)       self$paay <- PAA(self$y, self$frames)###########################################################################       #convert PN to symbolic representation###########################################################################       self$SAXstringx <- convert.to.SAX.symbol(self$paax, self$alpha)       self$SAXstringy <- convert.to.SAX.symbol(self$paay, self$alpha)       ###########################################################################      #store the SAX representation in an object###########################################################################       self$SAXarrayx[[1]] <- self$SAXstringx       self$SAXarrayy[[1]] <- self$SAXstringy              idx<- 2       printed<-0       ###########################################################################       # loop through the performance tabs in Sheet and repeat calculations pairwise###########################################################################       for (rec in self$performances) {                  cat(rec)         cat (", ")                  printed <- printed +1         self$xls <- read_xlsx(locationPNT, col_types=NULL, sheet=rec, col_names=TRUE, skip=1)                  self$x = as.numeric( self$xls[[RECcol1]] )          self$y = as.numeric( self$xls[[RECcol2]] )                   ###########################################################################        # normalize###########################################################################         self$x <- (self$x - mean(self$x)) /sd(self$x)         self$y <- (self$y - mean(self$y)) /sd(self$y)###########################################################################         # generate weighted series###########################################################################         self$z <- (self$x*weights[1]) + (self$y*self$weights[2])                  ############################################################################ generate PAA reductions###########################################################################         self$paax <- PAA(self$x, self$frames)         self$paay <- PAA(self$y, self$frames)         ###########################################################################         # convert to symbolic representation###########################################################################         self$SAXstringx <- convert.to.SAX.symbol(self$paax, self$alpha)         self$SAXstringy <- convert.to.SAX.symbol(self$paay, self$alpha)         ############################################################################ store the SAX representations in vector###########################################################################                  self$SAXarrayx[[idx]] <- self$SAXstringx         self$SAXarrayy[[idx]] <- self$SAXstringy                  idx <- idx+1         ###########################################################################        # line break after groups of 15 LINES (or any required number)###########################################################################                  if (printed == 15) {                      cat ("\n")           printed = 0         }       }     },       doDistanceMatrix = function(type) {              if (type==1) {         rownames(self$dm)<- c("PN", self$performances)         colnames(self$dm)<- c("PN", self$performances)                  for(i in 1:dim(self$dm)[1]) { # for each row           for(j in 1:dim(self$dm)[2]) { # for each column             self$dm[i,j] <-self$dmx[i,j]*weights[1] + self$dmy[i,j]*weights[2]         #weighted average               }         }###########################################################################         # output DM to disk###########################################################################         write.xlsx (self$dm, self$locationDM, sheetName="dm-Combined", col.names=TRUE, row.names=TRUE, append=TRUE)                }       if (type == 2) {         rownames(self$dmx)<- c("PN", self$performances)         colnames(self$dmx)<- c("PN", self$performances)                  for(i in 1:dim(self$dmx)[1]) { # for each row           for(j in 1:dim(self$dmx)[2]) { # for each column             self$dmx[i,j] <- self$pairwise(self$SAXarrayx[[i]], self$SAXarrayx[[j]])                }         } ###########################################################################        # output DM to disk###########################################################################         write.xlsx (self$dmx, self$locationDM, sheetName=PNTcolHead2, col.names=TRUE, row.names=TRUE, append=TRUE)       }       if (type == 3) {         rownames(self$dmy)<- c("PN", self$performances)         colnames(self$dmy)<- c("PN", self$performances)                  for(i in 1:dim(self$dmy)[1]) { # for each row           for(j in 1:dim(self$dmy)[2]) { # for each column             self$dmy[i,j] <- self$pairwise(self$SAXarrayy[[i]], self$SAXarrayy[[j]])                }         }############################################################################ output DM to disk###########################################################################         write.xlsx (self$dmy, self$locationDM, sheetName=PNTcolHead1, col.names=TRUE, row.names=TRUE, append=FALSE)                }            },          doSectionDMS = function() {        ###########################################################################      # now there is a call from Saxify.r to do the section DMs across all performances###########################################################################             ctr <- 1       for (sec in self$sections) {         ###########################################################################         # use the mapped bar numbers.###########################################################################         sec$getData(self$performances, self$alpha, beatsDroppedStart, beatsDroppedEnd)         cat("Section - ")         cat(sec$sectionNumber)         cat (": ")         cat (sec$sectionName)         cat (", ")         ###########################################################################        # only print subSectionName if non-blank (suppress NA)###########################################################################         if (!is.na(sec$subSectionName)) {cat (sec$subSectionName)}         cat("  #: ")         cat(ctr)         ctr <- ctr+1         cat(" of ")         cat(length(self$sections))         cat ("  Variable: ")############################################################################combined series is weighted on other two###########################################################################         for (type in 3:1) {            cat (type)           cat ("...")           sec$doDistanceMatrix(type)         }         cat("\n")       }     }        )    )  # Work.R version 2.0# Release Date			: June 2018# Author			: Eamon O Doherty# Copyrights asserted by 	: Eamon O Doherty (eamon.odoherty@gmail.com)# Warranties and guarantees	: None provided; use at your own risk# # This file: Work.R.docx